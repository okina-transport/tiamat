package org.rutebanken.tiamat.importer.finder;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.apache.commons.lang3.StringUtils;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Point;
import org.rutebanken.tiamat.domain.Provider;
import org.rutebanken.tiamat.general.PeriodicCacheLogger;
import org.rutebanken.tiamat.importer.StopPlaceSharingPolicy;
import org.rutebanken.tiamat.model.StopPlace;
import org.rutebanken.tiamat.repository.ProviderRepository;
import org.rutebanken.tiamat.repository.StopPlaceRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

@Component
public class SimpleNearbyStopPlaceFinder {

    private static final Logger logger = LoggerFactory.getLogger(SimpleNearbyStopPlaceFinder.class);

    private final StopPlaceRepository stopPlaceRepository;

    //Conversion between coordonate degrees and meters : 0.0001° = 11.132m

    //30m ~  0.0002695°
    private static final double BOUNDING_BOX_BUFFER_30M = 0.0002695;

    //100m ~  0.0008983°
    private static final double BOUNDING_BOX_BUFFER_100M = 0.0008983;

    @Value("${stopPlace.sharing.policy}")
    protected StopPlaceSharingPolicy sharingPolicy;

    ProviderRepository providerRepository;

    /**
     * Key is generated by using stop place's name, type and envelope.
     * Value is optional NetexId
     */
    private final Cache<String, List<String>> nearbyStopCache;

    @Autowired
    public SimpleNearbyStopPlaceFinder(StopPlaceRepository stopPlaceRepository,
                                 @Value("${nearbyStopPlaceFinderCache.maxSize:50000}") int maximumSize,
                                 @Value("${nearbyStopPlaceFinderCache.expiresAfter:30}") int expiresAfter,
                                 @Value("${nearbyStopPlaceFinderCache.expiresAfterTimeUnit:DAYS}") TimeUnit expiresAfterTimeUnit,
                                 PeriodicCacheLogger periodicCacheLogger,ProviderRepository providerRepository) {
        this.stopPlaceRepository = stopPlaceRepository;
        this.providerRepository = providerRepository;
        this.nearbyStopCache = CacheBuilder.newBuilder()
                .maximumSize(maximumSize)
                .expireAfterWrite(expiresAfter, expiresAfterTimeUnit)
                .recordStats()
                .build();

        periodicCacheLogger.scheduleCacheStatsLogging(nearbyStopCache, logger);
    }

    /**
     * Search into database nearby stops
     * @param stopPlace
     *      Stop place arround which the search must be done
     * @param maxDistance
     *      Maximum distance around the search center
     * @return
     *      List of stopPlaces around the center
     */
    public List<StopPlace> find(StopPlace stopPlace, double maxDistance) {

        List<StopPlace> resultList = new ArrayList<>();
        if (stopPlace.getCentroid() == null)
            return resultList;

        final String key = createKey(stopPlace, maxDistance);


        List<String> nearbyPlacesNetex = nearbyStopCache.getIfPresent(key);

        if (nearbyPlacesNetex == null || nearbyPlacesNetex.isEmpty()){
            Envelope boundingBox = createBoundingBox(stopPlace.getCentroid(),maxDistance);
            nearbyPlacesNetex = stopPlaceRepository.findNearbyStopPlace(boundingBox, stopPlace.getStopPlaceType(), getProviderToSearch(stopPlace));
        }

        if (!nearbyPlacesNetex.isEmpty()) {
            // Update cache for incoming envelope, so the same key will hopefullly match again
            nearbyStopCache.put(key, nearbyPlacesNetex);

            String maxDistanceLabel = Double.compare(maxDistance,BOUNDING_BOX_BUFFER_30M) == 0 ? "30m):" : "100m):";

            for (String stopPlaceNetexid : nearbyPlacesNetex) {

                StopPlace existingStopPlace = stopPlaceRepository.findFirstByNetexIdOrderByVersionDesc(stopPlaceNetexid);
                logger.info("Station found near stopPlace (under "+maxDistanceLabel+stopPlace.getOriginalIds()+"("+stopPlace.getCentroid()+")");
                logger.info("Existing stopPlace:"+existingStopPlace.getOriginalIds()+"("+existingStopPlace.getCentroid()+")");
                resultList.add(existingStopPlace);
            }
        }
        return resultList;
    }

    public List<StopPlace> findUnder30M(StopPlace stopPlace) {
        return find(stopPlace,BOUNDING_BOX_BUFFER_30M);
    }

    public List<StopPlace> findUnder100M(StopPlace stopPlace) {
        return find(stopPlace,BOUNDING_BOX_BUFFER_100M);
    }

    private Provider getProviderToSearch(StopPlace stopPlace){
        if (StopPlaceSharingPolicy.SHARED.equals(sharingPolicy)){
            //Tiamat runs on shared policy mode. StopPlace location must be searched on all provider spaces.
            return null;
        }

        //Tiamat runs on isolated mode. StopPlace must be searched only on the specified provider space
        return providerRepository.getProviders().stream()
                                                .filter(providerTmp -> providerTmp.getChouetteInfo().getReferential().equals(stopPlace.getProvider()))
                                                .findFirst()
                                                .orElseThrow(()->new RuntimeException("No provider found for code:" + stopPlace.getProvider())) ;
    }


    public final String createKey(StopPlace stopPlace, Envelope envelope) {
        if (StringUtils.isNotBlank(stopPlace.getProvider())){
            return stopPlace.getName() + "-" + stopPlace.getStopPlaceType().value() + "-" + stopPlace.getProvider() + "-" + envelope.toString();
        }
        else{
            return stopPlace.getName() + "-" + stopPlace.getStopPlaceType().value() + "-" + envelope.toString();
        }
    }

    public final String createKey(StopPlace stopPlace, double distance) {
        return createKey(stopPlace, createBoundingBox(stopPlace.getCentroid(),distance));
    }

    public Envelope createBoundingBox(Point point, double distance) {

        Geometry buffer = point.buffer(distance);

        Envelope envelope = buffer.getEnvelopeInternal();
        logger.trace("Created envelope {}", envelope.toString());

        return envelope;
    }


}
